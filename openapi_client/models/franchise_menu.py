# coding: utf-8

"""
    Waterloo OpenData API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: v3
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, ClassVar, Dict, List, Optional
from pydantic import BaseModel, StrictStr
from openapi_client.models.field_combos import FieldCombos
from openapi_client.models.field_franchise_logo import FieldFranchiseLogo
from openapi_client.models.metatags import Metatags
from openapi_client.models.path import Path
from openapi_client.models.rdf_mapping import RdfMapping
from openapi_client.models.title_field import TitleField
from openapi_client.models.translations import Translations
from openapi_client.models.workbench_moderation import WorkbenchModeration
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class FranchiseMenu(BaseModel):
    """
    FranchiseMenu
    """ # noqa: E501
    vid: Optional[StrictStr] = None
    uid: Optional[StrictStr] = None
    title: Optional[StrictStr] = None
    log: Optional[StrictStr] = None
    status: Optional[StrictStr] = None
    comment: Optional[StrictStr] = None
    promote: Optional[StrictStr] = None
    sticky: Optional[StrictStr] = None
    vuuid: Optional[StrictStr] = None
    nid: Optional[StrictStr] = None
    type: Optional[StrictStr] = None
    language: Optional[StrictStr] = None
    created: Optional[StrictStr] = None
    changed: Optional[StrictStr] = None
    tnid: Optional[StrictStr] = None
    translate: Optional[StrictStr] = None
    uuid: Optional[StrictStr] = None
    revision_timestamp: Optional[StrictStr] = None
    revision_uid: Optional[StrictStr] = None
    field_addons: Optional[Any] = None
    field_combos: Optional[FieldCombos] = None
    field_franchise_logo: Optional[FieldFranchiseLogo] = None
    field_individual_items: Optional[Any] = None
    title_field: Optional[TitleField] = None
    metatags: Optional[Metatags] = None
    rdf_mapping: Optional[RdfMapping] = None
    path: Optional[Path] = None
    translations: Optional[Translations] = None
    title_original: Optional[StrictStr] = None
    entity_translation_handler_id: Optional[StrictStr] = None
    title_language: Optional[StrictStr] = None
    cid: Optional[StrictStr] = None
    last_comment_timestamp: Optional[StrictStr] = None
    last_comment_name: Optional[Any] = None
    last_comment_uid: Optional[StrictStr] = None
    comment_count: Optional[StrictStr] = None
    name: Optional[StrictStr] = None
    picture: Optional[StrictStr] = None
    data: Optional[StrictStr] = None
    uw_page_settings_node_enable: Optional[StrictStr] = None
    workbench_moderation: Optional[WorkbenchModeration] = None
    __properties: ClassVar[List[str]] = ["vid", "uid", "title", "log", "status", "comment", "promote", "sticky", "vuuid", "nid", "type", "language", "created", "changed", "tnid", "translate", "uuid", "revision_timestamp", "revision_uid", "field_addons", "field_combos", "field_franchise_logo", "field_individual_items", "title_field", "metatags", "rdf_mapping", "path", "translations", "title_original", "entity_translation_handler_id", "title_language", "cid", "last_comment_timestamp", "last_comment_name", "last_comment_uid", "comment_count", "name", "picture", "data", "uw_page_settings_node_enable", "workbench_moderation"]

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True,
        "protected_namespaces": (),
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of FranchiseMenu from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of field_combos
        if self.field_combos:
            _dict['field_combos'] = self.field_combos.to_dict()
        # override the default output from pydantic by calling `to_dict()` of field_franchise_logo
        if self.field_franchise_logo:
            _dict['field_franchise_logo'] = self.field_franchise_logo.to_dict()
        # override the default output from pydantic by calling `to_dict()` of title_field
        if self.title_field:
            _dict['title_field'] = self.title_field.to_dict()
        # override the default output from pydantic by calling `to_dict()` of metatags
        if self.metatags:
            _dict['metatags'] = self.metatags.to_dict()
        # override the default output from pydantic by calling `to_dict()` of rdf_mapping
        if self.rdf_mapping:
            _dict['rdf_mapping'] = self.rdf_mapping.to_dict()
        # override the default output from pydantic by calling `to_dict()` of path
        if self.path:
            _dict['path'] = self.path.to_dict()
        # override the default output from pydantic by calling `to_dict()` of translations
        if self.translations:
            _dict['translations'] = self.translations.to_dict()
        # override the default output from pydantic by calling `to_dict()` of workbench_moderation
        if self.workbench_moderation:
            _dict['workbench_moderation'] = self.workbench_moderation.to_dict()
        # set to None if vid (nullable) is None
        # and model_fields_set contains the field
        if self.vid is None and "vid" in self.model_fields_set:
            _dict['vid'] = None

        # set to None if uid (nullable) is None
        # and model_fields_set contains the field
        if self.uid is None and "uid" in self.model_fields_set:
            _dict['uid'] = None

        # set to None if title (nullable) is None
        # and model_fields_set contains the field
        if self.title is None and "title" in self.model_fields_set:
            _dict['title'] = None

        # set to None if log (nullable) is None
        # and model_fields_set contains the field
        if self.log is None and "log" in self.model_fields_set:
            _dict['log'] = None

        # set to None if status (nullable) is None
        # and model_fields_set contains the field
        if self.status is None and "status" in self.model_fields_set:
            _dict['status'] = None

        # set to None if comment (nullable) is None
        # and model_fields_set contains the field
        if self.comment is None and "comment" in self.model_fields_set:
            _dict['comment'] = None

        # set to None if promote (nullable) is None
        # and model_fields_set contains the field
        if self.promote is None and "promote" in self.model_fields_set:
            _dict['promote'] = None

        # set to None if sticky (nullable) is None
        # and model_fields_set contains the field
        if self.sticky is None and "sticky" in self.model_fields_set:
            _dict['sticky'] = None

        # set to None if vuuid (nullable) is None
        # and model_fields_set contains the field
        if self.vuuid is None and "vuuid" in self.model_fields_set:
            _dict['vuuid'] = None

        # set to None if nid (nullable) is None
        # and model_fields_set contains the field
        if self.nid is None and "nid" in self.model_fields_set:
            _dict['nid'] = None

        # set to None if type (nullable) is None
        # and model_fields_set contains the field
        if self.type is None and "type" in self.model_fields_set:
            _dict['type'] = None

        # set to None if language (nullable) is None
        # and model_fields_set contains the field
        if self.language is None and "language" in self.model_fields_set:
            _dict['language'] = None

        # set to None if created (nullable) is None
        # and model_fields_set contains the field
        if self.created is None and "created" in self.model_fields_set:
            _dict['created'] = None

        # set to None if changed (nullable) is None
        # and model_fields_set contains the field
        if self.changed is None and "changed" in self.model_fields_set:
            _dict['changed'] = None

        # set to None if tnid (nullable) is None
        # and model_fields_set contains the field
        if self.tnid is None and "tnid" in self.model_fields_set:
            _dict['tnid'] = None

        # set to None if translate (nullable) is None
        # and model_fields_set contains the field
        if self.translate is None and "translate" in self.model_fields_set:
            _dict['translate'] = None

        # set to None if uuid (nullable) is None
        # and model_fields_set contains the field
        if self.uuid is None and "uuid" in self.model_fields_set:
            _dict['uuid'] = None

        # set to None if revision_timestamp (nullable) is None
        # and model_fields_set contains the field
        if self.revision_timestamp is None and "revision_timestamp" in self.model_fields_set:
            _dict['revision_timestamp'] = None

        # set to None if revision_uid (nullable) is None
        # and model_fields_set contains the field
        if self.revision_uid is None and "revision_uid" in self.model_fields_set:
            _dict['revision_uid'] = None

        # set to None if field_addons (nullable) is None
        # and model_fields_set contains the field
        if self.field_addons is None and "field_addons" in self.model_fields_set:
            _dict['field_addons'] = None

        # set to None if field_individual_items (nullable) is None
        # and model_fields_set contains the field
        if self.field_individual_items is None and "field_individual_items" in self.model_fields_set:
            _dict['field_individual_items'] = None

        # set to None if title_original (nullable) is None
        # and model_fields_set contains the field
        if self.title_original is None and "title_original" in self.model_fields_set:
            _dict['title_original'] = None

        # set to None if entity_translation_handler_id (nullable) is None
        # and model_fields_set contains the field
        if self.entity_translation_handler_id is None and "entity_translation_handler_id" in self.model_fields_set:
            _dict['entity_translation_handler_id'] = None

        # set to None if title_language (nullable) is None
        # and model_fields_set contains the field
        if self.title_language is None and "title_language" in self.model_fields_set:
            _dict['title_language'] = None

        # set to None if cid (nullable) is None
        # and model_fields_set contains the field
        if self.cid is None and "cid" in self.model_fields_set:
            _dict['cid'] = None

        # set to None if last_comment_timestamp (nullable) is None
        # and model_fields_set contains the field
        if self.last_comment_timestamp is None and "last_comment_timestamp" in self.model_fields_set:
            _dict['last_comment_timestamp'] = None

        # set to None if last_comment_name (nullable) is None
        # and model_fields_set contains the field
        if self.last_comment_name is None and "last_comment_name" in self.model_fields_set:
            _dict['last_comment_name'] = None

        # set to None if last_comment_uid (nullable) is None
        # and model_fields_set contains the field
        if self.last_comment_uid is None and "last_comment_uid" in self.model_fields_set:
            _dict['last_comment_uid'] = None

        # set to None if comment_count (nullable) is None
        # and model_fields_set contains the field
        if self.comment_count is None and "comment_count" in self.model_fields_set:
            _dict['comment_count'] = None

        # set to None if name (nullable) is None
        # and model_fields_set contains the field
        if self.name is None and "name" in self.model_fields_set:
            _dict['name'] = None

        # set to None if picture (nullable) is None
        # and model_fields_set contains the field
        if self.picture is None and "picture" in self.model_fields_set:
            _dict['picture'] = None

        # set to None if data (nullable) is None
        # and model_fields_set contains the field
        if self.data is None and "data" in self.model_fields_set:
            _dict['data'] = None

        # set to None if uw_page_settings_node_enable (nullable) is None
        # and model_fields_set contains the field
        if self.uw_page_settings_node_enable is None and "uw_page_settings_node_enable" in self.model_fields_set:
            _dict['uw_page_settings_node_enable'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of FranchiseMenu from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "vid": obj.get("vid"),
            "uid": obj.get("uid"),
            "title": obj.get("title"),
            "log": obj.get("log"),
            "status": obj.get("status"),
            "comment": obj.get("comment"),
            "promote": obj.get("promote"),
            "sticky": obj.get("sticky"),
            "vuuid": obj.get("vuuid"),
            "nid": obj.get("nid"),
            "type": obj.get("type"),
            "language": obj.get("language"),
            "created": obj.get("created"),
            "changed": obj.get("changed"),
            "tnid": obj.get("tnid"),
            "translate": obj.get("translate"),
            "uuid": obj.get("uuid"),
            "revision_timestamp": obj.get("revision_timestamp"),
            "revision_uid": obj.get("revision_uid"),
            "field_addons": obj.get("field_addons"),
            "field_combos": FieldCombos.from_dict(obj.get("field_combos")) if obj.get("field_combos") is not None else None,
            "field_franchise_logo": FieldFranchiseLogo.from_dict(obj.get("field_franchise_logo")) if obj.get("field_franchise_logo") is not None else None,
            "field_individual_items": obj.get("field_individual_items"),
            "title_field": TitleField.from_dict(obj.get("title_field")) if obj.get("title_field") is not None else None,
            "metatags": Metatags.from_dict(obj.get("metatags")) if obj.get("metatags") is not None else None,
            "rdf_mapping": RdfMapping.from_dict(obj.get("rdf_mapping")) if obj.get("rdf_mapping") is not None else None,
            "path": Path.from_dict(obj.get("path")) if obj.get("path") is not None else None,
            "translations": Translations.from_dict(obj.get("translations")) if obj.get("translations") is not None else None,
            "title_original": obj.get("title_original"),
            "entity_translation_handler_id": obj.get("entity_translation_handler_id"),
            "title_language": obj.get("title_language"),
            "cid": obj.get("cid"),
            "last_comment_timestamp": obj.get("last_comment_timestamp"),
            "last_comment_name": obj.get("last_comment_name"),
            "last_comment_uid": obj.get("last_comment_uid"),
            "comment_count": obj.get("comment_count"),
            "name": obj.get("name"),
            "picture": obj.get("picture"),
            "data": obj.get("data"),
            "uw_page_settings_node_enable": obj.get("uw_page_settings_node_enable"),
            "workbench_moderation": WorkbenchModeration.from_dict(obj.get("workbench_moderation")) if obj.get("workbench_moderation") is not None else None
        })
        return _obj


